---
title: Achilles' Tent Notes &#35;11
layout: notes
hidden: true
---

- [Achilles' Tent Notes &#35;8](/research/2019-10-13-achilles-8)
- [Achilles' Tent Notes &#35;9](/research/2019-10-15-achilles-9)
- [Achilles' Tent Notes &#35;10](/research/2019-10-28-achilles-10)

### Parties & Protocols

- `enum Other { Ip(...), Mem(...), ... }`
- `trait Protocol`
- `enum Party { Me, Other(Other), Protocol(Box<Protocol>) }`

All of `Me`, `Other` and `Protocol` implement `trait Party` (maybe `Entity`).

#### Same source, with CLI flags:

- `A` runs with `--parties=[10.0.1.1, @me, 10.0.1.2]`
- `B` runs with `--parties=[@me, 10.0.1.0, 10.0.1.2]`
- `C` runs with `--parties=[10.0.1.1, 10.0.1.0, @me]`

```rust
use achillies::party::{Party, Other};

let [A, B, C] = parse_flags();
let P = init_protocol! {
  GC(3);

  Garbler   => [A, B],
  Evaluator => C,
};

let i@A     = read_env();
let j@{B,C} = gen_rand();
// TODO: What would happen if the above was just `i@B`? Would it be `None` for
// `C`?

let x = P.conceal(i, A);
let y = P.conceal(j, B);
let z = P.conceal(j, C);

// ... logic on x, y, and z.
// e.g.

let r = obliv if x > y {
  x + z
} else {
  x - z
};

P.reveal(r, A);
```

#### Different source (`C`'s shown):

```rust
use achillies::party::{Party, Other};

let P = init_protocol! {
  GC(3);

  Garbler => [
    Party::Other(Other::Ip("10.0.1.1")),
    Party::Other(Other::Ip("10.0.1.0")),
  ],
  Evaluator => Party::Me,
};

let i = gen_rand();
let x = P.recv(A);
let y = P.recv(B);
let z = P.send(i);

// ... logic on x, y, and z.
// e.g.

let r = obliv if x > y {
  x + z
} else {
  x - z
};

P.reveal(r, A);
```

TODO:

- `GC(3)` should be something like a `Party::Protocol`

### Example Sorting Implementation

```rust
/// You start with an slice of `Obliv<T>` meaning you know essentailly nothing
/// but the length of the slice. After merging, you end up with a `Vec` of
/// `Obliv<T>` again meaning that you know nothing but the length. This means
/// this function **should not** leak, for instance, the order of the elements
/// in the original slice. See `leaky_merge`.
fn merge<T: PartialOrd>(left: &[Obliv<T>], right: &[Obliv<T>])
    -> Vec<Obliv<T>>
{
    let out_len = left.len() + right.len();
    let mut out = Vec::with_capacity(out_len);

    // Both `left_i` and `right_i` must be `Obliv` types, because they will
    // need to be mutated inside the `obliv if`, which is disallowed otherwise.
    // This makes sense, because inspection of the current left and right slice
    // index while running the following `for` loop would leak the ....
    //
    // The `Obliv` type is public information at first however, since it's well
    // established that any instance of this sorting algorithm starts at the
    // 0th index of each slice.
    let mut left_i = Obliv::public(0);
    let mut right_i = Obliv::public(0);

    for i in 0..out_len {
        // NOTE: Vec<T>[Obliv<usize>] is a linear scan over the whole vec.
        // TODO: We need to maintain the logic of a short curcuit `||`.
        let element = obliv if left_i == Obliv::public(left.len()) ||
                               right[right_i] < left[left_i]
        {
            let o = right[right_i];
            right_i += 1;
            o
        } else {
            let o = left[left_i];
            left_i += 1;
            o
        };
        out.push(element);
    }
    out
}
leaky_merge<T: PartialOrd>(left: &[Obliv<T>], right: &[Obliv<T>])
    -> Vec<Obliv<T>>
{
    let out_len = left.len() + right.len();
    let mut out = Vec::with_capacity(out_len);

    let mut left_i = 0;
    let mut right_i = 0;

    for i in 0..out_len {
        let element = obliv if left_i == left.len() ||
                               right[right_i] < left[left_i]
        {
            let o = right[right_i];
            right_i += 1;
            o
        } else {
            let o = left[left_i];
            left_i += 1;
            o
        };

        // We didn't declare obliv index (aka linear scan), so this leaks the
        // original order.
        println!("{}", left_i, right_i);
        out.push(element);
    }
    out
}

fn merge_sort<T: Clone + PartialOrd>(slice: &[Obliv<T>]) -> Vec<Obliv<T>> {
    if slice.len() == 1 { return slice.to_owned() }
    let mid   = slice.len() / 2;
    let left  = merge_sort(slice[0..mid]);
    let right = merge_sort(slice[mid..slice.len()]);
    merge(left, right)
}
```
