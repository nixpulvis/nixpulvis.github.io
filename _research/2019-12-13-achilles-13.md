---
title: Achilles' Tent Notes &#35;13
layout: note
hidden: true
---

- [Achilles' Tent Notes &#35;8](/research/2019-10-13-achilles-8)
- [Achilles' Tent Notes &#35;9](/research/2019-10-15-achilles-9)
- [Achilles' Tent Notes &#35;10](/research/2019-10-28-achilles-10)
- [Achilles' Tent Notes &#35;11](/research/2019-11-11-achilles-11)
- [Achilles' Tent Notes &#35;12](/research/2019-12-02-achilles-12)

### Party Perspectives `@P { ... }`

When writing classic local programs (e.g. Rust 2018) all bindings have affinity
to the only local party, you (or `@me`). To bridge the gap into the MPC
context, we allow `global!` blocks `@P { e }` to only evaluate into `Some(e)`
if the party running the block locally is `@P`.

```rust
// Ideal syntax?
let r: Option<i32> = @A { rand() };

// Macro syntax?
let r: Option<i32> = global!(@A { rand() });
```

This composes with `conceal` which can accept an `Option<T>` from a party.

```rust
let r: Option<i32> = @A { rand() };
let s: Obliv<i32> = conceal!(r, @P <= @A)
```

`conceal!` also gives shorthand for creating and consuming the `Option` at
once.

```rust
let s: Obliv<i32> = conceal!(@P <= @A { rand() });
```

The following would fail to type check, since `r` is only `Some` for `@A`, but
we're saying here that `@B` is providing this value.

```rust
let s: Obliv<i32> = conceal!(r, @P <= @B)
```

To participate in a protocol where we do not know the block which the other
party is executing, we can use `concealed!`.

```rust
let s: Obliv<i32> = concealed!(@P <= @B);
```

This allows `@A` and `@B` to write partially separated code.

```rust
// @A's code:
let s = conceal!(@P <= @A { rand() });
let t = concealed!(@P <= @B);

// @B's code:
let s = concealed!(@P <= @A);
let t = conceal!(@P <= @B { read() });
```

Which could be rewritten to expose the `rand` and `read` calls as the
following.

```rust
let s = conceal!(@P <= @A { rand() });
let t = conceal!(@P <= @B { read() });
```

### Special `@me` Party

```rust
fn is_mine<@P, 'a, T>(x: &'a T @P) -> bool {
    if @P == @me {
        true
    } else {
        false
    }
}

// Always true.
let x = 1;
assert!(is_mine(&x));

// Fails for `@B`.
let x = @A { 1 };
assert!(is_mine(&x));
```

### Example `invertPerm` Function

```rust
fn invertPerm<@P, @A, @B>(x: Vec<Obliv<usize>>)
    -> Vec<Obliv<usize>>
    where @P: @A + @B
{
    let (pa, pa_waksman) = conceal!(@P <= @A {
        let lpa: Vec<usize> = randomPermutation();
        let lpa_waksman: Vec<usize> = waksmansBits(&lpa);
        (lpa, lpa_waksman)
    });

    let pb: Vec<Obliv<usize>> = waksmanPerm(&x, &pa_waksman);
    let pb_local: Option<Vec<usize>> = reveal!(pb, @P => @B);

    let pbinv_waksman = conceal!(@P <= @B {
        let pbinv: Vec<usize> = invertPermutation(&pb_local);
        waksmanBits(&pbinv)
    });

    waksmanPerm(&pa, &pbinv_waksman)
}
```
